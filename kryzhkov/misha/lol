
Алгоритм Дейкстры
Программирование. Подготовка к олимпиадам. 9–11 классы.
Алгоритм Дейкстры назван в честь голландского ученого Эдсгера Дейкстры (Edsger Dijkstra). Алгоритм был предложен в 1959 году для нахождения кратчайших путей от одной вершины до всех остальных в ориентированном взвешенном графе, при условии, что все ребра в графе имеют неотрицательные веса.
Рассмотрим две модели хранения взвешенного графа в памяти. В первой модели (матрица весов, аналог матрицы смежности) будем считать, что вес ребра из вершины i в вершину j равен W[i][j], то есть в матрице W хранятся веса ребра для любых двух вершин. Если из вершины i в вершину j нет ребра, то W[i][j]==INF для некоторого специального значения константы INF. Значение INF следует выбирать исходя из задачи, например, если речь идет о расстояниях между какими-либо населенными пунктами Земли, то можно выбрать значение INF равным 109 километров.
Алгоритм Дейкстры относится к так называемым «жадным» алгоритмам. Пусть расстояние от начальной вершины start до вершины i хранится в массиве D[i]. Начальные значения D[start]=0, D[i]=INF для всех остальных вершин i. То есть в самом начале алгоритму известен путь из вершины start до вершины start длины 0, а до остальных вершин кратчайшие пути неизвестны. Между тем алгоритм будет постепенно улучшать значения в массиве D, в результате получит кратчайшие расстояния до всех вершин.
Основная идея для улучшения называется «релаксацией ребра». Пусть из вершины i в вершину j есть ребро веса W[i][j], при этом выполнено неравенство D[i] + W[i][j] < D[j]. То есть можно построить маршрут из начальной вершины до вершины i и добавить к нему ребро из i в j, и суммарная стоимость такого маршрута будет меньше, чем известная ранее стоимость маршрута из начальной вершины в вершину j. Тогда можно улучшить значение D[j], присвоив D[j] = D[i] + W[i][j].
В алгоритме Дейкстры вершины красятся в два цвета, будем говорить, что вершина «неокрашенная» или «окрашенная». Изначально все вершины неокрашенные. Если алгоритм Дейкстры покрасил вершину i, то это означает, что найденное значение D[i] является наилучшим возможным и в последствии не будет улучшаться, то есть значение D[i] является кратчайшим расстоянием от начальной вершины до вершины i. Если же вершина не покрашена, то величина D[i] для такой вершины i равна кратчайшему пути из вершины start до вершины i, который проходит только по покрашенным вершинам (за исключением самой вершины i).
На каждом шаге алгоритма Дейкстры красится одна новая вершина. В качестве такой вершины выбирается неокрашенная вершина i с наименьшим значением D[i]. Затем рассматриваются все ребра, исходящие из вершины i, и производится релаксация этих ребер, то есть улучшаются расстояния до вершин, смежных с i.
Алгоритм заканчивается, когда на очередном шаге не останется неокрашенных вершин или если расстояние до всех неокрашенных вершин будет равно INF (то есть эти вершины являются недостижимыми).
Запишем алгоритм Дейкстры. Пусть N — число вершин в графе, вершины пронумерованы от 0 до N-1. Номер начальной вершины — start и веса ребер хранятся в матрице W.
INF = 10 ** 10
D = [INF] * N
D[start] = 0
Colored = [False] * N
while True:
    min_dist = INF
    for i in range(N):
        if not Colored[i] and D[i] < min_dist:
            min_dist = D[i] 
            min_vertex = i 
    if min_dist == INF: 
        break
    i = min_vertex 
    Colored[i] = True 
    for j in range(N): 
        if D[i] + W[i][j] < D[j]: 
            D[j] = D[i] + W[i][j] 
print(D)
Список Colored будет хранить информацию о том, была ли покрашена вершина. Сначала инициализируются списки D и Colored. Затем запускается внешний цикл алгоритма, который выбирает неокрашенную вершину с минимальным расстоянием, номер этой вершины хранится в переменной min_vertex, а расстояние до этой вершины — в переменной min_dist. Если же min_dist оказывается равно INF, то значит все неокрашенные вершины являются недостижимыми и алгоритм заканчивает свою работу. Иначе найденная вершина окрашивается и после этого релаксируются все ребра, исходящие из этой вершины.
Данный алгоритм имеет сложность O(n2), так как внешний цикл может быть выполнен до n раз, внутри него содержится два цикла, каждый из которых также выполняется n раз.
Для восстановления ответа, то есть для нахождения пути из начальной вершины до всех остальных, необходимо построить дерево кратчайших путей. Это дерево будет состоять из тех ребер, которые были успешно срелаксированы в результате исполнения алгоритма. То есть если происходит релаксация ребра из i в j, то теперь кратчайший маршрут из вершины start до вершины j должен проходить через вершину i и затем содержать ребро i-j. Тем самым вершина i становится предшественником вершины j на кратчайшем пути из начальной вершины до вершины j.
Рассмотрим реализацию алгоритм Дейкстры с восстановлением ответа на графе, хранимым в виде списка смежности. Набор вершин, смежных с вершиной i будет храниться в множествве W[i]. Также необходимо хранить веса ребер, будем считать, что для хранения весов ребер используется словарь Weight, где ключом является кортеж из двух вершин. То есть вес ребра из i в j хранится в элементе Weight[i, j] словаря весов.
D = [INF] * N
D[start] = 0
Prev = [None] * N
Colored = [False] * N
while True:
    min_dist = INF
    for i in range(N): 
    if not Colored[i] and D[i] < min_dist: 
        min_dist = D[i] 
        min_vertex = i 
    if min_dist == INF:
        break
    i = min_vertex
    Colored[i] = True
    for j in W[i]:
        if D[i] + Weight[i, j] < D[j]: 
            D[j] = D[i] + Weight[i, j] 
            Prev[j] = i
Для нахождения кратчайшего пути из вершины start до вершины j будем переходить от каждой вершины к ее предшественнику:
Path =[] 
while j is not None:
    Path.append(j) 
    j = Prev[j] 
    Path = Path[::-1]
Алгоритм Дейкстры применим только в том случае, когда веса всех ребер неотрицательные. Это гарантирует то, что после окраски расстояние до вершины не может быть улучшено. Если в графе могут быть ребра отрицательного веса, то следует использовать другие алгоритмы.
Есть модификация алгоритма Дейкстры, которая более эффективна на разреженных графах. Поскольку необходимо обновлять расстояния до вершин и выбирать из неокрашенных вершин ту, до которой расстояние наименьшее, то можно хранить все неокрашенные вершины в куче. Тогда выбор наименьшей вершины будет выполняться за O(logn), что позволит более оптимально выбирать очередную окрашиваемую вершину. Но обновление расстояния до вершины в этом случае будет выполняться также за O(logn), так как это требует перестройки кучи. Если в графе m ребер, то максимальное число релаксаций ребер также будет не больше m и суммарная сложность всех релаксаций будет O(mlogn). Таким образом, алгоритм Дейкстры с использованием кучи будет иметь сложность O(nlogn+mlogn)=O((n+m)logn). Если граф — разреженный, то такой алгоритм работает существенно быстрее, чем обычный алгоритм Дейкстры.

  
